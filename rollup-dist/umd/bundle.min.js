!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports):"function"==typeof define&&define.amd?define(["exports"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).leetcode={})}(this,(function(t){"use strict";const e=function(t,e){if(0===t.length)return-1;let n=0,r=t.length-1;for(;n<=r;){const o=Math.floor((n+r)/2);if(t[o]===e)return o;t[n]<=t[o]?e>=t[n]&&e<t[o]?r=o-1:n=o+1:e>t[o]&&e<=t[r]?n=o+1:r=o-1}return-1};const n=function(t,e){if(0===t.length)return[-1,-1];const n=((t,e)=>{let n=0,r=t.length-1;for(;n<=r;){const o=Math.floor((n+r)/2);if(t[o]===e){if(0===o||t[o-1]<e)return o;r=o-1}else t[o]>e?r=o-1:n=o+1}return-1})(t,e);if(-1===n)return[-1,-1];const r=((t,e)=>{let n=0,r=t.length-1;for(;n<=r;){const o=Math.floor((n+r)/2);if(t[o]===e){if(o===t.length-1||t[o+1]>e)return o;n=o+1}else t[o]>e?r=o-1:n=o+1}return-1})(t,e);return[n,r]};class r{tree;n;data;constructor(t){this.data=[...t],this.n=t.length,this.tree=new Array(4*this.n).fill(0),this.build(0,0,this.n-1)}build(t,e,n){if(e===n)return void(this.tree[t]=this.data[e]);const r=Math.floor((e+n)/2),o=2*t+1,s=2*t+2;this.build(o,e,r),this.build(s,r+1,n),this.tree[t]=this.tree[o]+this.tree[s]}updateTree(t,e,n,r,o){if(e===n)return this.data[r]=o,void(this.tree[t]=o);const s=Math.floor((e+n)/2),i=2*t+1,l=2*t+2;r<=s?this.updateTree(i,e,s,r,o):this.updateTree(l,s+1,n,r,o),this.tree[t]=this.tree[i]+this.tree[l]}query(t,e,n,r,o){if(r>n||o<e)return 0;if(r<=e&&n<=o)return this.tree[t];const s=Math.floor((e+n)/2),i=2*t+1,l=2*t+2;return this.query(i,e,s,r,o)+this.query(l,s+1,n,r,o)}update(t,e){this.updateTree(0,0,this.n-1,t,e)}queryRange(t,e){return this.query(0,0,this.n-1,t,e)}getData(){return[...this.data]}}
/*!SECTION

给你一个数组 nums ，请你完成两类查询。

其中一类查询要求 更新 数组 nums 下标对应的值
另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left <= right
实现 NumArray 类：

NumArray(int[] nums) 用整数数组 nums 初始化对象
void update(int index, int val) 将 nums[index] 的值 更新 为 val
int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]）
 

示例 1：

输入：
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
输出：
[null, 9, null, 8]

解释：
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1,2,5]
numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
 

提示：

1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
0 <= index < nums.length
-100 <= val <= 100
0 <= left <= right < nums.length
调用 update 和 sumRange 方法次数不大于 3 * 104
*/const o=class{segmentTree;constructor(t){this.segmentTree=new r(t)}update(t,e){this.segmentTree.update(t,e)}sumRange(t,e){return this.segmentTree.queryRange(t,e)}};const s=function(t){const e=t.length;if(0===e)return[];const n=Array.from(new Set(t)).sort(((t,e)=>t-e)),r=new Map;n.forEach(((t,e)=>r.set(t,e+1)));const o=new Array(n.length+1).fill(0),s=t=>{for(;t<o.length;)o[t]+=1,t+=t&-t},i=t=>{let e=0;for(;t>0;)e+=o[t],t-=t&-t;return e},l=new Array(e).fill(0);for(let n=e-1;n>=0;n--){const e=r.get(t[n]);l[n]=i(e-1),s(e)}return l};
/*!SECTION
给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。

区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

 
示例 1：
输入：nums = [-2,5,-1], lower = -2, upper = 2
输出：3
解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。
示例 2：

输入：nums = [0], lower = 0, upper = 0
输出：1
 
提示：

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
-105 <= lower <= upper <= 105
题目数据保证答案是一个 32 位 的整数
*/const i=function(t,e,n){if(0===t.length)return 0;const r=new Array(t.length+1).fill(0);for(let e=0;e<t.length;e++)r[e+1]=r[e]+t[e];const o=(t,s)=>{if(t===s)return 0;const i=Math.floor((t+s)/2);let l=o(t,i)+o(i+1,s),f=i+1,u=i+1;for(let o=t;o<=i;o++){for(;f<=s&&r[f]-r[o]<e;)f++;for(;u<=s&&r[u]-r[o]<=n;)u++;l+=u-f}const h=new Array(s-t+1);let c=t,a=i+1,g=0;for(;c<=i&&a<=s;)h[g++]=r[c]<=r[a]?r[c++]:r[a++];for(;c<=i;)h[g++]=r[c++];for(;a<=s;)h[g++]=r[a++];for(let e=0;e<h.length;e++)r[t+e]=h[e];return l};return o(0,r.length-1)};
/*!SECTION

给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。

你需要返回给定数组中的重要翻转对的数量。

示例 1:

输入: [1,3,2,3,1]
输出: 2
示例 2:

输入: [2,4,3,5,1]
输出: 3
注意:

给定数组的长度不会超过50000。
输入数组中的所有数字都在32位整数的表示范围内。

*/function l(t){if(t.length<=1)return 0;const e=new Set;for(const n of t){e.add(n);const t=2n*BigInt(n);t<=BigInt(Number.MAX_SAFE_INTEGER)&&t>=BigInt(Number.MIN_SAFE_INTEGER)&&e.add(Number(t))}const n=Array.from(e).sort(((t,e)=>t-e)),o=new Map;n.forEach(((t,e)=>{o.set(t,e)}));const s=new r(new Array(n.length).fill(0));let i=0;for(let e=0;e<t.length;e++){const r=t[e],l=2n*BigInt(r),f=Number(l);let u=0,h=n.length-1,c=n.length;for(;u<=h;){const t=Math.floor((u+h)/2);n[t]>f?(c=t,h=t-1):u=t+1}if(c<n.length){i+=s.queryRange(c,n.length-1)}const a=o.get(r),g=s.queryRange(a,a);s.update(a,g+1)}return i}const f=l;const u=function(t){let e=0,n=t.length-1,r=0;for(;r<=n;)0===t[r]?([t[e],t[r]]=[t[r],t[e]],e++,r++):2===t[r]?([t[n],t[r]]=[t[r],t[n]],n--):r++};t.SegmentTree=r,t.debug=function(...t){console.debug("[bunder::debug]",...t)},t.lc307=o,t.lc315=s,t.lc327=i,t.lc33=e,t.lc34=n,t.lc493=f,t.lc75=u,t.reversePairs=l}));