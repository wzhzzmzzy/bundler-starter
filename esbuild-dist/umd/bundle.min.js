"use strict";var globalThis=globalThis||{};globalThis.leetcode=(()=>{var w=Object.defineProperty;var N=Object.getOwnPropertyDescriptor;var T=Object.getOwnPropertyNames;var I=Object.prototype.hasOwnProperty;var M=(r,e,t)=>e in r?w(r,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):r[e]=t;var S=(r,e)=>{for(var t in e)w(r,t,{get:e[t],enumerable:!0})},v=(r,e,t,n)=>{if(e&&typeof e=="object"||typeof e=="function")for(let o of T(e))!I.call(r,o)&&o!==t&&w(r,o,{get:()=>e[o],enumerable:!(n=N(e,o))||n.enumerable});return r};var A=r=>v(w({},"__esModule",{value:!0}),r);var g=(r,e,t)=>M(r,typeof e!="symbol"?e+"":e,t);var P={};S(P,{SegmentTree:()=>p,debug:()=>L,lc307:()=>B,lc315:()=>C,lc327:()=>F,lc33:()=>q,lc34:()=>k,lc493:()=>G,lc75:()=>D,reversePairs:()=>y});function R(r,e){if(r.length===0)return-1;let t=0,n=r.length-1;for(;t<=n;){let o=Math.floor((t+n)/2);if(r[o]===e)return o;r[t]<=r[o]?e>=r[t]&&e<r[o]?n=o-1:t=o+1:e>r[o]&&e<=r[n]?t=o+1:n=o-1}return-1}var q=R;function E(r,e){if(r.length===0)return[-1,-1];let t=(l,i)=>{let u=0,h=l.length-1;for(;u<=h;){let c=Math.floor((u+h)/2);if(l[c]===i){if(c===0||l[c-1]<i)return c;h=c-1}else l[c]>i?h=c-1:u=c+1}return-1},n=(l,i)=>{let u=0,h=l.length-1;for(;u<=h;){let c=Math.floor((u+h)/2);if(l[c]===i){if(c===l.length-1||l[c+1]>i)return c;u=c+1}else l[c]>i?h=c-1:u=c+1}return-1},o=t(r,e);if(o===-1)return[-1,-1];let f=n(r,e);return[o,f]}var k=E;var p=class{constructor(e){g(this,"tree");g(this,"n");g(this,"data");this.data=[...e],this.n=e.length,this.tree=new Array(4*this.n).fill(0),this.build(0,0,this.n-1)}build(e,t,n){if(t===n){this.tree[e]=this.data[t];return}let o=Math.floor((t+n)/2),f=2*e+1,l=2*e+2;this.build(f,t,o),this.build(l,o+1,n),this.tree[e]=this.tree[f]+this.tree[l]}updateTree(e,t,n,o,f){if(t===n){this.data[o]=f,this.tree[e]=f;return}let l=Math.floor((t+n)/2),i=2*e+1,u=2*e+2;o<=l?this.updateTree(i,t,l,o,f):this.updateTree(u,l+1,n,o,f),this.tree[e]=this.tree[i]+this.tree[u]}query(e,t,n,o,f){if(o>n||f<t)return 0;if(o<=t&&n<=f)return this.tree[e];let l=Math.floor((t+n)/2),i=2*e+1,u=2*e+2,h=this.query(i,t,l,o,f),c=this.query(u,l+1,n,o,f);return h+c}update(e,t){this.updateTree(0,0,this.n-1,e,t)}queryRange(e,t){return this.query(0,0,this.n-1,e,t)}getData(){return[...this.data]}};var x=class{constructor(e){g(this,"segmentTree");this.segmentTree=new p(e)}update(e,t){this.segmentTree.update(e,t)}sumRange(e,t){return this.segmentTree.queryRange(e,t)}};var B=x;function _(r){let e=r.length;if(e===0)return[];let t=Array.from(new Set(r)).sort((u,h)=>u-h),n=new Map;t.forEach((u,h)=>n.set(u,h+1));let o=new Array(t.length+1).fill(0),f=u=>{for(;u<o.length;)o[u]+=1,u+=u&-u},l=u=>{let h=0;for(;u>0;)h+=o[u],u-=u&-u;return h},i=new Array(e).fill(0);for(let u=e-1;u>=0;u--){let h=n.get(r[u]);i[u]=l(h-1),f(h)}return i}var C=_;function V(r,e,t){if(r.length===0)return 0;let n=new Array(r.length+1).fill(0);for(let f=0;f<r.length;f++)n[f+1]=n[f]+r[f];let o=(f,l)=>{if(f===l)return 0;let i=Math.floor((f+l)/2),u=o(f,i)+o(i+1,l),h=i+1,c=i+1;for(let s=f;s<=i;s++){for(;h<=l&&n[h]-n[s]<e;)h++;for(;c<=l&&n[c]-n[s]<=t;)c++;u+=c-h}let b=new Array(l-f+1),m=f,a=i+1,d=0;for(;m<=i&&a<=l;)b[d++]=n[m]<=n[a]?n[m++]:n[a++];for(;m<=i;)b[d++]=n[m++];for(;a<=l;)b[d++]=n[a++];for(let s=0;s<b.length;s++)n[f+s]=b[s];return u};return o(0,n.length-1)}var F=V;function y(r){if(r.length<=1)return 0;let e=new Set;for(let l of r){e.add(l);let i=BigInt(l)*2n;i<=BigInt(Number.MAX_SAFE_INTEGER)&&i>=BigInt(Number.MIN_SAFE_INTEGER)&&e.add(Number(i))}let t=Array.from(e).sort((l,i)=>l-i),n=new Map;t.forEach((l,i)=>{n.set(l,i)});let o=new p(new Array(t.length).fill(0)),f=0;for(let l=0;l<r.length;l++){let i=r[l],u=BigInt(i)*2n,h=Number(u),c=0,b=t.length-1,m=t.length;for(;c<=b;){let s=Math.floor((c+b)/2);t[s]>h?(m=s,b=s-1):c=s+1}if(m<t.length){let s=o.queryRange(m,t.length-1);f+=s}let a=n.get(i),d=o.queryRange(a,a);o.update(a,d+1)}return f}var G=y;function j(r){let e=0,t=r.length-1,n=0;for(;n<=t;)r[n]===0?([r[e],r[n]]=[r[n],r[e]],e++,n++):r[n]===2?([r[t],r[n]]=[r[n],r[t]],t--):n++}var D=j;function L(...r){console.debug("[bunder::debug]",...r)}return A(P);})();
/*!SECTION

给你一个数组 nums ，请你完成两类查询。

其中一类查询要求 更新 数组 nums 下标对应的值
另一类查询要求返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 ，其中 left <= right
实现 NumArray 类：

NumArray(int[] nums) 用整数数组 nums 初始化对象
void update(int index, int val) 将 nums[index] 的值 更新 为 val
int sumRange(int left, int right) 返回数组 nums 中索引 left 和索引 right 之间（ 包含 ）的nums元素的 和 （即，nums[left] + nums[left + 1], ..., nums[right]）
 

示例 1：

输入：
["NumArray", "sumRange", "update", "sumRange"]
[[[1, 3, 5]], [0, 2], [1, 2], [0, 2]]
输出：
[null, 9, null, 8]

解释：
NumArray numArray = new NumArray([1, 3, 5]);
numArray.sumRange(0, 2); // 返回 1 + 3 + 5 = 9
numArray.update(1, 2);   // nums = [1,2,5]
numArray.sumRange(0, 2); // 返回 1 + 2 + 5 = 8
 

提示：

1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
0 <= index < nums.length
-100 <= val <= 100
0 <= left <= right < nums.length
调用 update 和 sumRange 方法次数不大于 3 * 104 
*/
/*!SECTION
给你一个整数数组 nums 以及两个整数 lower 和 upper 。求数组中，值位于范围 [lower, upper] （包含 lower 和 upper）之内的 区间和的个数 。

区间和 S(i, j) 表示在 nums 中，位置从 i 到 j 的元素之和，包含 i 和 j (i ≤ j)。

 
示例 1：
输入：nums = [-2,5,-1], lower = -2, upper = 2
输出：3
解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。
示例 2：

输入：nums = [0], lower = 0, upper = 0
输出：1
 
提示：

1 <= nums.length <= 105
-231 <= nums[i] <= 231 - 1
-105 <= lower <= upper <= 105
题目数据保证答案是一个 32 位 的整数
*/
/*!SECTION

给定一个数组 nums ，如果 i < j 且 nums[i] > 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。

你需要返回给定数组中的重要翻转对的数量。

示例 1:

输入: [1,3,2,3,1]
输出: 2
示例 2:

输入: [2,4,3,5,1]
输出: 3
注意:

给定数组的长度不会超过50000。
输入数组中的所有数字都在32位整数的表示范围内。

*/
